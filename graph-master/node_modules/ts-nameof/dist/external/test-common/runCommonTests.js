"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var assert = __importStar(require("assert"));
var prettier = __importStar(require("prettier"));
function runCommonTests(getTransformedText, options) {
    if (options === void 0) { options = {}; }
    describe("nameof", function () {
        describe("bad call expressions", function () {
            it("should throw if someone does not provide arguments or type arguments", function () {
                runThrowTest("nameof();", "Call expression must have one argument or type argument: nameof()");
            });
        });
        describe("argument", function () {
            it("should get the result of an identifier", function () {
                runTest("nameof(myObj);", "\"myObj\";");
            });
            it("should get the result of the this keyword", function () {
                runTest("nameof(this);", "\"this\";");
            });
            it("should get the result of a property access expression", function () {
                runTest("nameof(myObj.prop);", "\"prop\";");
            });
            it("should get the result of an expression with a parenthesized expression", function () {
                runTest("nameof((myObj).prop);", "\"prop\";");
            });
            it("should get the result of an expression with a type assertion", function () {
                runTest("nameof((myObj as any).prop);", "\"prop\";");
            });
            it("should get the result of a property access expression with null assertion operators", function () {
                runTest("nameof(myObj!.prop!);", "\"prop\";");
            });
            it("should get the result of an identifier with a dollar sign", function () {
                runTest("nameof(myObj.$prop);", "\"$prop\";");
            });
            it("should resolve to string when nesting nameofs", function () {
                runTest("nameof(nameof(testing));", "\"testing\";");
            });
        });
        describe("type parameter", function () {
            it("should get the result of an identifier", function () {
                runTest("nameof<Test>();", "\"Test\";");
            });
            it("should get the result of a fully qualified name", function () {
                runTest("nameof<This.Is.A.Test>();", "\"Test\";");
            });
            it("should get an identifier with a dollar sign", function () {
                runTest("nameof<Test$>();", "\"Test$\";");
            });
            it("should handle when someone uses an import type as not the last node", function () {
                runTest("nameof<import('test').prop>();", "\"prop\";");
            });
            it("should throw when someone only uses an import type", function () {
                runThrowTest("nameof<import('test')>();", "The node `import(\"test\")` is not supported in this scenario.");
            });
            it("should throw when someone only uses an import type with typeof", function () {
                runThrowTest("nameof<typeof import('test')>();", "The node `typeof import(\"test\")` is not supported in this scenario.");
            });
        });
        describe("arrays", function () {
            it("should include the brackets", function () {
                runTest("nameof(anyProp[0]);", "\"anyProp[0]\";");
            });
            it("should get after the period", function () {
                runTest("nameof(anyProp[0].prop);", "\"prop\";");
            });
            it("should escape strings inside element access expressions", function () {
                runTest("nameof(obj[\"prop\"]);", "\"obj[\\\"prop\\\"]\";");
            });
            it("should include the brackets when getting an ambient declaration's property", function () {
                runTest("nameof<MyInterface>(i => i.prop[0]);", "\"prop[0]\";");
            });
            it("should include the nested brackets when getting an ambient declaration's property", function () {
                runTest("nameof<MyInterface>(i => i.prop[0][1]);", "\"prop[0][1]\";");
            });
            it("should include brackets nested in brackets", function () {
                runTest("nameof<MyInterface>(i => i.prop[prop[0]]);", "\"prop[prop[0]]\";");
            });
            it("should not allow only an array", function () {
                runThrowTest("nameof([0]);");
            });
        });
        describe("with function", function () {
            it("should get the last string", function () {
                runTest("nameof<MyInterface>(i => i.prop1.prop2);", "\"prop2\";");
            });
            it("should get from the return statement", function () {
                runTest("nameof<MyInterface>(i => { console.log('test'); return i.prop1.prop2; });", "\"prop2\";");
            });
            it("should handle when someone uses an import type", function () {
                runTest("nameof<import('test')>(x => x.Foo);", "\"Foo\";");
            });
            it("should throw when using an element access expression directly on the object", function () {
                runThrowTest("nameof<MyInterface>(i => i[\"prop1\"]);", "First accessed property must not be computed: (i) => i[\"prop1\"]");
            });
            it("should throw when the function doesn't have a period", function () {
                runThrowTest("nameof<MyInterface>(i => i);", "A property must be accessed on the object: (i) => i");
            });
            it("should throw when the function doesn't have a return statement", function () {
                var errorPrefix = "Cound not find return statement with an expression in function expression: ";
                var possibleMessages = [
                    errorPrefix + "{ i; }",
                    errorPrefix + "{\n    i;\n}"
                ];
                runThrowTest("nameof<MyInterface>(i => { i; });", possibleMessages);
            });
        });
        describe("literals", function () {
            it("should leave the string literal as-is", function () {
                runTest("nameof(\"test\");", "\"test\";");
            });
            it("should transform a numeric literal as a string", function () {
                runTest("nameof(5);", "\"5\";");
            });
        });
        describe("other", function () {
            it("should ignore spread syntax", function () {
                runTest("nameof(...test);", "\"test\";");
            });
        });
    });
    describe("nameof.full", function () {
        describe("bad call expressions", function () {
            it("should throw if someone does not provide arguments or type arguments", function () {
                runThrowTest("nameof.full();", "Unsupported use of nameof.full: nameof.full()");
            });
        });
        describe("argument", function () {
            it("should include everything when no count arg is provided", function () {
                runTest("nameof.full(obj.prop.other);", "\"obj.prop.other\";");
            });
            it("should not include null assertion operators", function () {
                runTest("nameof.full(obj!.prop!.other!);", "\"obj.prop.other\";");
            });
            it("should not include null assertion operators when also using element access expressions", function () {
                runTest("nameof.full(obj!.prop![0].other!);", "\"obj.prop[0].other\";");
            });
            it("should escape string literals in element access expressions", function () {
                runTest("nameof.full(obj.prop[\"other\"]);", "\"obj.prop[\\\"other\\\"]\";");
            });
            it("should allow using a period index", function () {
                runTest("nameof.full(MyTest.Test.This, 1);", "\"Test.This\";");
            });
            it("should allow using a period index of 0", function () {
                runTest("nameof.full(MyTest.Test.This, 0);", "\"MyTest.Test.This\";");
            });
            it("should allow using a period index up to its max value", function () {
                runTest("nameof.full(MyTest.Test.This, 2);", "\"This\";");
            });
            it("should allow using a negative period index", function () {
                runTest("nameof.full(MyTest.Test.This, -1);", "\"This\";");
            });
            it("should allow using a negative period index to its max value", function () {
                runTest("nameof.full(MyTest.Test.This, -3);", "\"MyTest.Test.This\";");
            });
            it("should throw when the periodIndex is not a number literal", function () {
                runThrowTest("nameof.full(MyTest.Test, 'test')", "Expected count to be a number, but was: \"test\"");
            });
            it("should throw when the periodIndex is greater than the number of periods", function () {
                runThrowTest("nameof.full(MyTest.Test, 2)", "Count of 2 was larger than max count of 1: nameof.full(MyTest.Test, 2)");
            });
            it("should throw when the absolute value of the negative periodIndex is greater than the number of periods + 1", function () {
                runThrowTest("nameof.full(MyTest.Test, -3)", "Count of -3 was larger than max count of -2: nameof.full(MyTest.Test, -3)");
            });
            it("should resolve to string when nesting nameofs", function () {
                runTest("nameof.full(nameof(testing));", "\"testing\";");
            });
        });
        describe("type parameter", function () {
            it("should include everything when no count arg is provided", function () {
                runTest("nameof.full<Some.Test.Name>();", "\"Some.Test.Name\";");
            });
            it("should allow using a period index", function () {
                runTest("nameof.full<MyTest.Test.This>(1);", "\"Test.This\";");
            });
            it("should allow using a period index of 0", function () {
                runTest("nameof.full<MyTest.Test.This>(0);", "\"MyTest.Test.This\";");
            });
            it("should allow using a period index up to its max value", function () {
                runTest("nameof.full<MyTest.Test.This>(2);", "\"This\";");
            });
            it("should allow using a negative period index", function () {
                runTest("nameof.full<MyTest.Test.This>(-1);", "\"This\";");
            });
            it("should allow using a negative period index to its max value", function () {
                runTest("nameof.full<MyTest.Test.This>(-3);", "\"MyTest.Test.This\";");
            });
            it("should throw when the periodIndex is not a number literal", function () {
                runThrowTest("nameof.full<MyTest.Test>('test')", "Expected count to be a number, but was: \"test\"");
            });
            it("should throw when the periodIndex is greater than the number of periods", function () {
                runThrowTest("nameof.full<MyTest.Test>(2)", "Count of 2 was larger than max count of 1: nameof.full<MyTest.Test>(2)");
            });
            it("should throw when the absolute value of the negative periodIndex is greater than the number of periods + 1", function () {
                runThrowTest("nameof.full<MyTest.Test>(-3)", "Count of -3 was larger than max count of -2: nameof.full<MyTest.Test>(-3)");
            });
            it("should throw when someone uses an import type", function () {
                runThrowTest("nameof.full<import('test').other.test>();", "The node `import(\"test\").other.test` is not supported in this scenario.");
            });
        });
        describe("arrays", function () {
            it("should include the brackets", function () {
                runTest("nameof.full(anyProp[0].myProp);", "\"anyProp[0].myProp\";");
            });
        });
        describe("with function", function () {
            it("should get the text", function () {
                runTest("nameof.full<MyInterface>(i => i.prop1.prop2);", "\"prop1.prop2\";");
            });
            it("should get the text without the null assertion operator", function () {
                runTest("nameof.full<MyInterface>(i => i.prop1!.prop2!);", "\"prop1.prop2\";");
            });
            it("should get the text when there's a trailing comma with whitespace", function () {
                runTest("nameof.full<IState>(state => state.field.dates, );", "\"field.dates\";");
            });
            it("should get the text when using a function", function () {
                runTest("nameof.full<MyInterface>(function(i) { return i.prop1.prop2; });", "\"prop1.prop2\";");
            });
            it("should get the text when providing a period", function () {
                runTest("nameof.full<MyInterface>(i => i.prop1.prop2, 0);", "\"prop1.prop2\";");
                runTest("nameof.full<MyInterface>(i => i.prop1.prop2, 1);", "\"prop2\";");
                runTest("nameof.full<MyInterface>(i => i.prop1.prop2.prop3, -1);", "\"prop3\";");
            });
            it("should throw when the function doesn't have a period", function () {
                runThrowTest("nameof.full<MyInterface>(i => i);", "A property must be accessed on the object: (i) => i");
            });
        });
    });
    describe("toArray", function () {
        it("should return an array of values when given a function that returns an array as input", function () {
            runTest("nameof.toArray<MyInterface>(o => [o.Prop1, o.Prop2, o.Prop3]);", "[\"Prop1\", \"Prop2\", \"Prop3\"];");
        });
        it("should return an array of values when given multiple arguments", function () {
            runTest("nameof.toArray(myObject.Prop1, otherObject.Prop2);", "[\"Prop1\", \"Prop2\"];");
        });
        it("should return an array with a single element if a non-function argument is passed", function () {
            runTest("nameof.toArray(myObject.Prop1);", "[\"Prop1\"];");
        });
        it("should support nested nameof calls", function () {
            runTest("nameof.toArray(nameof.full(Some.Qualified.Name), Some.Qualified.Name);", "[\"Some.Qualified.Name\", \"Name\"];");
        });
        it("should support a non-arrow function expression", function () {
            runTest("nameof.toArray<MyInterface>(function(o) { return [o.Prop1, o.Prop2]; });", "[\"Prop1\", \"Prop2\"];");
        });
        it("should throw when the function argument does not return an array", function () {
            runThrowTest("nameof.toArray<MyInterface>(o => o.Prop1);", "Unsupported toArray call expression, an array must be returned by the provided function: nameof.toArray<MyInterface>((o) => o.Prop1)");
        });
        it("should throw when no arguments are provided", function () {
            runThrowTest("nameof.toArray<MyInterface>();", "Unable to parse call expression, no arguments provided: nameof.toArray<MyInterface>()");
        });
    });
    describe("general", function () {
        it("should error when specifying a different nameof property", function () {
            runThrowTest("nameof.nonExistent()", "Unsupported nameof call expression with property 'nonExistent': nameof.nonExistent()");
        });
        it("should replace handling comments", function () {
            var input = "nameof(window);\n// nameof(window);\nnameof(window);\n/* nameof(window); nameof(window); */\nnameof(window);\n";
            var expected = "\"window\";\n// nameof(window);\n\"window\";\n/* nameof(window); nameof(window); */\n\"window\";\n";
            runTest(input, expected);
        });
        it("should replace handling strings", function () {
            var input = "nameof(window);\nconst t = /`/g;\n`nameof(window); /\n${nameof(window)}\n${nameof(alert)}\nnameof(window);\n`; //test\n\"nameof(window);\";\n\"\\\"nameof(window);\";\n'nameof(window);';\n'\\'\\\"nameof(window);';\n\"C:\\\\\";\nnameof(window);\n`${() => {\n  nameof(console);\n}}`;\n";
            var expected = "\"window\";\nconst t = /`/g;\n`nameof(window); /\n${\"window\"}\n${\"alert\"}\nnameof(window);\n`; //test\n\"nameof(window);\";\n\"\\\"nameof(window);\";\n\"nameof(window);\";\n'\\'\\\"nameof(window);';\n\"C:\\\\\";\n\"window\";\n`${() => {\n  \"console\";\n}}`;\n";
            runTest(input, expected);
        });
        it("should handle division operators", function () {
            var input = "const t = 2 / 1;\nnameof(testing);";
            var expected = "const t = 2 / 1;\n\"testing\";";
            runTest(input, expected);
        });
    });
    function runTest(text, expected) {
        if (options.commonPrefix != null)
            text = options.commonPrefix + text;
        var result = getTransformedText(text);
        if (!expected.endsWith("\n"))
            expected += "\n";
        assert.equal(prettier.format(result, { parser: "typescript" }), expected);
    }
    function runThrowTest(text, possibleExpectedMessages) {
        if (options.commonPrefix != null)
            text = options.commonPrefix + text;
        var transformedText;
        try {
            transformedText = getTransformedText(text);
        }
        catch (ex) {
            possibleExpectedMessages = getPossibleExpectedMessages();
            if (possibleExpectedMessages == null)
                return;
            var actualMessage = ex.message;
            for (var _i = 0, possibleExpectedMessages_1 = possibleExpectedMessages; _i < possibleExpectedMessages_1.length; _i++) {
                var message = possibleExpectedMessages_1[_i];
                if (message === actualMessage)
                    return;
            }
            throw new Error("Expected the error message of " + actualMessage + " to equal one of the following messages: " + possibleExpectedMessages);
        }
        throw new Error("Expected to throw, but returned: " + transformedText);
        function getPossibleExpectedMessages() {
            var result = getAsArray();
            if (result == null)
                return undefined;
            for (var i = result.length - 1; i >= 0; i--) {
                result[i] = "[ts-nameof]: " + result[i];
                result.push("./ts-nameof.macro: " + result[i]);
            }
            return result;
            function getAsArray() {
                if (typeof possibleExpectedMessages === "string")
                    return [possibleExpectedMessages];
                if (possibleExpectedMessages instanceof Array)
                    return possibleExpectedMessages;
                return undefined;
            }
        }
    }
}
exports.runCommonTests = runCommonTests;
